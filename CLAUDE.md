# Kigiri

This is a Rust-based compiler for a programming language.

It uses pest for parsing, a custom intermediate representation (IR) for code generation, and LLVM for backend
compilation.

## Development Commands

Main commands:

- `just test` - Run tests
- `just test-verbose` - Run tests with output capture disabled
- `just lint` - Check formatting and run clippy with fixes
- `just fmt` - Format code with `cargo fmt --all`
- `just clean` - Clean build artifacts and coverage data
- `just audit` - Check dependencies for security vulnerabilities
- `just audit-fix` - Preview automatic fixes for vulnerabilities (dry-run)
- `just coverage` - Generate code coverage report using nextest
- `just coverage-html` - Generate HTML coverage report using nextest
- `just coverage-lcov` - Generate LCOV format coverage for CI using nextest
- `just` - Run test, lint, and formatter.

Note: The project uses `cargo nextest` for testing instead of standard `cargo test`.

### Core Pipeline

The compilation process follows a multi-phase pipeline:

1. **parser** - Lexing and parsing using Pest grammar
    - `grammar.pest` defines the language grammar
    - Produces an AST from source code
    - Entry point: `parse()`

2. **semantic_analysis** - Type checking and semantic validation
    - Two-phase process: declaration collection then type resolution
    - `SemanticAnalyzer` orchestrates the analysis phases
    - Transforms parsed AST to typed AST (`PhaseTypeResolved`)
    - Symbol table management for scopes and variables

3. **codegen** - IR generation from typed AST
    - `ir_builder::build_ir_module()` converts typed AST to intermediate representation
    - Custom IR with basic blocks and instructions
    - Handles control flow and variable management

4. **backend_llvm** - LLVM code generation and compilation
    - `ir_to_llvm()` converts custom IR to LLVM IR
    - Uses inkwell (LLVM 18.1) for Rust-LLVM bindings
    - Leverages LLVM's optimization passes and native code generation
    - Final compilation target for producing executable binaries

### Compilation Phases

The codebase uses a phase-based compilation model where AST nodes are parameterized by compilation phase:

- `PhaseParsed` - Raw parsed AST
- `PhaseTypeResolved` - After semantic analysis with type information

### Testing

- Uses `insta` for snapshot testing
- Tests are organized per crate with some integration tests
- LLVM backend has generated semantic tests

### Code Coverage

- Uses `cargo-llvm-cov` for precise LLVM-based coverage measurement
- Install with: `cargo install cargo-llvm-cov`
- All coverage commands automatically use nextest for consistency
- Generate reports with `just coverage-html` for interactive HTML reports

### Key Dependencies

- `pest`/`pest_derive` for parsing
- `inkwell` for LLVM integration (version 0.6.0 with LLVM 18.1)
- `string-interner` for string interning
- `bumpalo` for arena allocation
- `insta` for snapshot testing

## Instructions for Claude

### Code Quality

- Always run `just fmt` after making any code changes
- Run `just lint` before completing tasks to ensure code quality
- Use `just test` to verify changes don't break existing functionality

### Development Workflow

- Follow the existing code patterns and conventions in the codebase
- Respect the phase-based compilation model when working with AST nodes
- When adding new features, consider which compilation phase they belong to
- Maintain consistency with existing error handling and testing patterns

### Testing

- Use `cargo nextest` (via `just test`) for running tests, not `cargo test`
- Add appropriate tests for new functionality
- Update snapshot tests when making changes that affect output

### Documentation

- Keep comments focused and minimal - let the code speak for itself
- Update this CLAUDE.md file if adding new development commands or changing the architecture

### Git Commits

- Write succinct commit messages that fit in 80 characters, subject line only
- Use conventional commit format: `type: description` (e.g., `feat:`, `fix:`, `docs:`, `refactor:`)
- Use `ai` prefix for plans or tasks generated by AI
- Only add a description body when warranted - try hard to avoid needing it
- Keep messages focused on what changed, not why (the code should explain why)
- Do not add "Generated with Claude Code" or "Co-Authored-By: Claude" footers
